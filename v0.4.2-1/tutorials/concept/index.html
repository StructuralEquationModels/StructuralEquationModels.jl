<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Our Concept of a Structural Equation Model · StructuralEquationModels.jl</title><meta name="title" content="Our Concept of a Structural Equation Model · StructuralEquationModels.jl"/><meta property="og:title" content="Our Concept of a Structural Equation Model · StructuralEquationModels.jl"/><meta property="twitter:title" content="Our Concept of a Structural Equation Model · StructuralEquationModels.jl"/><meta name="description" content="Documentation for StructuralEquationModels.jl."/><meta property="og:description" content="Documentation for StructuralEquationModels.jl."/><meta property="twitter:description" content="Documentation for StructuralEquationModels.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon_zeta.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="StructuralEquationModels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">StructuralEquationModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">A fast and flexible SEM framework</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../first_model/">A first model</a></li><li class="is-active"><a class="tocitem" href>Our Concept of a Structural Equation Model</a><ul class="internal"><li><a class="tocitem" href="#The-observed-part-aka-[SemObserved](@ref)"><span>The observed part aka <code>SemObserved</code></span></a></li><li><a class="tocitem" href="#The-implied-part-aka-[SemImplied](@ref)"><span>The implied part aka <code>SemImplied</code></span></a></li><li><a class="tocitem" href="#The-loss-part-aka-SemLoss"><span>The loss part aka <code>SemLoss</code></span></a></li><li><a class="tocitem" href="#The-optimizer-part-aka-SemOptimizer"><span>The optimizer part aka <code>SemOptimizer</code></span></a></li><li class="toplevel"><a class="tocitem" href="#What-to-do-next"><span>What to do next</span></a></li><li class="toplevel"><a class="tocitem" href="#API-model-parts"><span>API - model parts</span></a></li><li><a class="tocitem" href="#observed"><span>observed</span></a></li><li><a class="tocitem" href="#implied"><span>implied</span></a></li><li><a class="tocitem" href="#loss-functions"><span>loss functions</span></a></li><li><a class="tocitem" href="#optimizer"><span>optimizer</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Model Specification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../specification/specification/">Model specification</a></li><li><a class="tocitem" href="../specification/graph_interface/">Graph interface</a></li><li><a class="tocitem" href="../specification/ram_matrices/">RAMMatrices interface</a></li><li><a class="tocitem" href="../specification/parameter_table/">ParameterTable interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Model Construction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../construction/construction/">Model Construction</a></li><li><a class="tocitem" href="../construction/outer_constructor/">Outer Constructor</a></li><li><a class="tocitem" href="../construction/build_by_parts/">Build by parts</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Optimization Backends</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../backends/optim/">Using Optim.jl</a></li><li><a class="tocitem" href="../backends/nlopt/">Using NLopt.jl</a></li></ul></li><li><a class="tocitem" href="../fitting/fitting/">Model Fitting</a></li><li><a class="tocitem" href="../inspection/inspection/">Model Inspection</a></li><li><a class="tocitem" href="../meanstructure/">Mean Structures</a></li><li><input class="collapse-toggle" id="menuitem-2-9" type="checkbox"/><label class="tocitem" for="menuitem-2-9"><span class="docs-label">Collections</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../collection/collection/">Collections</a></li><li><a class="tocitem" href="../collection/multigroup/">Multigroup models</a></li></ul></li><li><a class="tocitem" href="../constraints/constraints/">Constraints</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Developer documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../developer/extending/">Extending the package</a></li><li><a class="tocitem" href="../../developer/loss/">Custom loss functions</a></li><li><a class="tocitem" href="../../developer/implied/">Custom implied types</a></li><li><a class="tocitem" href="../../developer/optimizer/">Custom optimizer types</a></li><li><a class="tocitem" href="../../developer/observed/">Custom observed types</a></li><li><a class="tocitem" href="../../developer/sem/">Custom model types</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Advanced tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../regularization/regularization/">Regularization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Performance tips</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../performance/sorting/">Model sorting</a></li><li><a class="tocitem" href="../../performance/mkl/">MKL</a></li><li><a class="tocitem" href="../../performance/simulation/">Simulation studies</a></li><li><a class="tocitem" href="../../performance/symbolic/">Symbolic precomputation</a></li><li><a class="tocitem" href="../../performance/starting_values/">Starting values</a></li><li><a class="tocitem" href="../../performance/parametric/">Parametric Types</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Internals and design</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../internals/internals/">Internals and design</a></li><li><a class="tocitem" href="../../internals/files/">files</a></li><li><a class="tocitem" href="../../internals/types/">types</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Our Concept of a Structural Equation Model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Our Concept of a Structural Equation Model</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/main/docs/src/tutorials/concept.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Our-Concept-of-a-Structural-Equation-Model"><a class="docs-heading-anchor" href="#Our-Concept-of-a-Structural-Equation-Model">Our Concept of a Structural Equation Model</a><a id="Our-Concept-of-a-Structural-Equation-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Our-Concept-of-a-Structural-Equation-Model" title="Permalink"></a></h1><p>In our package, every Structural Equation Model (<code>Sem</code>) consists of three parts (four, if you count the optimizer):</p><p><img src="../../assets/concept.svg" alt="SEM concept"/></p><p>Those parts are interchangable building blocks (like &#39;Legos&#39;), i.e. there are different pieces available you can choose as the <code>observed</code> slot of the model, and stick them together with other pieces that can serve as the <code>implied</code> part.</p><p>The <code>observed</code> part is for observed data, the <code>implied</code> part is what the model implies about your data (e.g. the model implied covariance matrix), and the loss part compares the observed data and implied properties (e.g. weighted least squares difference between the observed and implied covariance matrix). The optimizer part is not part of the model itself, but it is needed to fit the model as it connects to the optimization backend (e.g. the type of optimization algorithm used).</p><p>For example, to build a model for maximum likelihood estimation with the NLopt optimization suite as a backend you would choose <code>SemML</code> as a loss function and <code>SemOptimizerNLopt</code> as the optimizer.</p><p>As you can see, a model can have as many loss functions as you want it to have. We always optimize over their (weighted) sum. So to build a model for ridge regularized full information maximum likelihood estimation, you would choose two loss functions, <code>SemFIML</code> and <code>SemRidge</code>.</p><p>In julia, everything has a type. To make more precise which objects can be used as the different building blocks, we require them to have a certain type:</p><p><img src="../../assets/concept_typed.svg" alt="SEM concept typed"/></p><p>So everything that can be used as the &#39;observed&#39; part has to be of type <code>SemObserved</code>.</p><p>Here is an overview on the available building blocks:</p><table><tr><th style="text-align: right"><a href="#StructuralEquationModels.SemObserved"><code>SemObserved</code></a></th><th style="text-align: right"><a href="#StructuralEquationModels.SemImplied"><code>SemImplied</code></a></th><th style="text-align: right"><a href="#StructuralEquationModels.SemLossFunction"><code>SemLossFunction</code></a></th><th style="text-align: right"><a href="#StructuralEquationModels.SemOptimizer"><code>SemOptimizer</code></a></th></tr><tr><td style="text-align: right"><a href="#StructuralEquationModels.SemObservedData"><code>SemObservedData</code></a></td><td style="text-align: right"><a href="#StructuralEquationModels.RAM"><code>RAM</code></a></td><td style="text-align: right"><a href="#StructuralEquationModels.SemML"><code>SemML</code></a></td><td style="text-align: right"><a href="#StructuralEquationModels.SemOptimizerOptim"><code>SemOptimizerOptim</code></a></td></tr><tr><td style="text-align: right"><a href="#StructuralEquationModels.SemObservedCovariance"><code>SemObservedCovariance</code></a></td><td style="text-align: right"><a href="#StructuralEquationModels.RAMSymbolic"><code>RAMSymbolic</code></a></td><td style="text-align: right"><a href="#StructuralEquationModels.SemWLS"><code>SemWLS</code></a></td><td style="text-align: right"><a href="#StructuralEquationModels.SemOptimizerNLopt"><code>SemOptimizerNLopt</code></a></td></tr><tr><td style="text-align: right"><a href="#StructuralEquationModels.SemObservedMissing"><code>SemObservedMissing</code></a></td><td style="text-align: right"><a href="#StructuralEquationModels.ImpliedEmpty"><code>ImpliedEmpty</code></a></td><td style="text-align: right"><a href="#StructuralEquationModels.SemFIML"><code>SemFIML</code></a></td><td style="text-align: right"></td></tr><tr><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"><a href="#StructuralEquationModels.SemRidge"><code>SemRidge</code></a></td><td style="text-align: right"></td></tr><tr><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"><a href="#StructuralEquationModels.SemConstant"><code>SemConstant</code></a></td><td style="text-align: right"></td></tr></table><p>The rest of this page explains the building blocks for each part. First, we explain every part and give an overview on the different options that are available. After that, the <a href="#API-model-parts">API - model parts</a> section serves as a reference for detailed explanations about the different options. (How to stick them together to a final model is explained in the section on <a href="../construction/construction/#Model-Construction">Model Construction</a>.)</p><h2 id="The-observed-part-aka-[SemObserved](@ref)"><a class="docs-heading-anchor" href="#The-observed-part-aka-[SemObserved](@ref)">The observed part aka <a href="#StructuralEquationModels.SemObserved"><code>SemObserved</code></a></a><a id="The-observed-part-aka-[SemObserved](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#The-observed-part-aka-[SemObserved](@ref)" title="Permalink"></a></h2><p>The <em>observed</em> part contains all necessary information about the observed data. Currently, we have three options: <a href="#StructuralEquationModels.SemObservedData"><code>SemObservedData</code></a> for fully observed datasets, <a href="#StructuralEquationModels.SemObservedCovariance"><code>SemObservedCovariance</code></a> for observed covariances (and means) and <a href="#StructuralEquationModels.SemObservedMissing"><code>SemObservedMissing</code></a> for data that contains missing values.</p><h2 id="The-implied-part-aka-[SemImplied](@ref)"><a class="docs-heading-anchor" href="#The-implied-part-aka-[SemImplied](@ref)">The implied part aka <a href="#StructuralEquationModels.SemImplied"><code>SemImplied</code></a></a><a id="The-implied-part-aka-[SemImplied](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#The-implied-part-aka-[SemImplied](@ref)" title="Permalink"></a></h2><p>The <em>implied</em> part is what your model implies about the data, for example, the model-implied covariance matrix. There are two options at the moment: <a href="#StructuralEquationModels.RAM"><code>RAM</code></a>, which uses the reticular action model to compute the model implied covariance matrix, and <a href="#StructuralEquationModels.RAMSymbolic"><code>RAMSymbolic</code></a> which does the same but symbolically pre-computes part of the model, which increases subsequent performance in model fitting (see <a href="../../performance/symbolic/#Symbolic-precomputation">Symbolic precomputation</a>). There is also a third option, <a href="#StructuralEquationModels.ImpliedEmpty"><code>ImpliedEmpty</code></a> that can serve as a &#39;placeholder&#39; for models that do not need an implied part.</p><h2 id="The-loss-part-aka-SemLoss"><a class="docs-heading-anchor" href="#The-loss-part-aka-SemLoss">The loss part aka <code>SemLoss</code></a><a id="The-loss-part-aka-SemLoss-1"></a><a class="docs-heading-anchor-permalink" href="#The-loss-part-aka-SemLoss" title="Permalink"></a></h2><p>The loss part specifies the objective that is optimized to find the parameter estimates. If it contains more then one loss function (aka <a href="#StructuralEquationModels.SemLossFunction"><code>SemLossFunction</code></a>)), we find the parameters by minimizing the sum of loss functions (for example in maximum likelihood estimation + ridge regularization). Available loss functions are</p><ul><li><a href="#StructuralEquationModels.SemML"><code>SemML</code></a>: maximum likelihood estimation</li><li><a href="#StructuralEquationModels.SemWLS"><code>SemWLS</code></a>: weighted least squares estimation</li><li><a href="#StructuralEquationModels.SemFIML"><code>SemFIML</code></a>: full-information maximum likelihood estimation</li><li><a href="#StructuralEquationModels.SemRidge"><code>SemRidge</code></a>: ridge regularization</li></ul><h2 id="The-optimizer-part-aka-SemOptimizer"><a class="docs-heading-anchor" href="#The-optimizer-part-aka-SemOptimizer">The optimizer part aka <code>SemOptimizer</code></a><a id="The-optimizer-part-aka-SemOptimizer-1"></a><a class="docs-heading-anchor-permalink" href="#The-optimizer-part-aka-SemOptimizer" title="Permalink"></a></h2><p>The optimizer part of a model connects to the numerical optimization backend used to fit the model.  It can be used to control options like the optimization algorithm, linesearch, stopping criteria, etc.  There are currently three available backends, <a href="#StructuralEquationModels.SemOptimizerOptim"><code>SemOptimizerOptim</code></a> connecting to the <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a> backend, <a href="#StructuralEquationModels.SemOptimizerNLopt"><code>SemOptimizerNLopt</code></a> connecting to the <a href="https://github.com/JuliaOpt/NLopt.jl">NLopt.jl</a> backend and <a href="../regularization/regularization/#SemOptimizerProximal"><code>SemOptimizerProximal</code></a> connecting to <a href="https://github.com/JuliaFirstOrder/ProximalAlgorithms.jl">ProximalAlgorithms.jl</a>. For more information about the available options see also the tutorials about <a href="../backends/optim/#Using-Optim.jl">Using Optim.jl</a> and <a href="../backends/nlopt/#Using-NLopt.jl">Using NLopt.jl</a>, as well as <a href="../constraints/constraints/#Constrained-optimization">Constrained optimization</a> and <a href="../regularization/regularization/#Regularization">Regularization</a> .</p><h1 id="What-to-do-next"><a class="docs-heading-anchor" href="#What-to-do-next">What to do next</a><a id="What-to-do-next-1"></a><a class="docs-heading-anchor-permalink" href="#What-to-do-next" title="Permalink"></a></h1><p>You now have an understanding of our representation of structural equation models.</p><p>To learn more about how to use the package, you may visit the remaining tutorials.</p><p>If you want to learn how to extend the package (e.g., add a new loss function), you may visit <a href="../../developer/extending/#Extending-the-package">Extending the package</a>.</p><h1 id="API-model-parts"><a class="docs-heading-anchor" href="#API-model-parts">API - model parts</a><a id="API-model-parts-1"></a><a class="docs-heading-anchor-permalink" href="#API-model-parts" title="Permalink"></a></h1><h2 id="observed"><a class="docs-heading-anchor" href="#observed">observed</a><a id="observed-1"></a><a class="docs-heading-anchor-permalink" href="#observed" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructuralEquationModels.SemObserved" href="#StructuralEquationModels.SemObserved"><code>StructuralEquationModels.SemObserved</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Supertype of all objects that can serve as the observed field of a SEM. Pre-processes data and computes sufficient statistics for example. If you have a special kind of data, e.g. ordinal data, you should implement a subtype of SemObserved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/d0ff25b70ae22945cdc4315679a10efa97be64ad/src/types.jl#L100-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructuralEquationModels.SemObservedData" href="#StructuralEquationModels.SemObservedData"><code>StructuralEquationModels.SemObservedData</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>For observed data without missings.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">SemObservedData(;
    data,
    observed_vars = nothing,
    specification = nothing,
    kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>data</code>: observed data – <em>DataFrame</em> or <em>Matrix</em></li><li><code>observed_vars::Vector{Symbol}</code>: column names of the data (if the object passed as data does not have column names, i.e. is not a data frame)</li><li><code>specification</code>: optional SEM specification (<a href="#StructuralEquationModels.SemSpecification"><code>SemSpecification</code></a>)</li></ul><p><strong>Extended help</strong></p><p><strong>Interfaces</strong></p><ul><li><p><code>nsamples(::SemObservedData)</code> -&gt; number of observed data points</p></li><li><p><code>nobserved_vars(::SemObservedData)</code> -&gt; number of observed (manifested) variables</p></li><li><p><code>samples(::SemObservedData)</code> -&gt; observed data</p></li><li><p><code>obs_cov(::SemObservedData)</code> -&gt; observed covariance matrix</p></li><li><p><code>obs_mean(::SemObservedData)</code> -&gt; observed mean vector</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/d0ff25b70ae22945cdc4315679a10efa97be64ad/src/observed/data.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructuralEquationModels.SemObservedCovariance" href="#StructuralEquationModels.SemObservedCovariance"><code>StructuralEquationModels.SemObservedCovariance</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Type alias for <a href="#StructuralEquationModels.SemObservedData"><code>SemObservedData</code></a> that has mean and covariance, but no actual data.</p><p>For instances of <code>SemObservedCovariance</code> <a href="#StructuralEquationModels.samples"><code>samples</code></a> returns <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/d0ff25b70ae22945cdc4315679a10efa97be64ad/src/observed/covariance.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructuralEquationModels.SemObservedMissing" href="#StructuralEquationModels.SemObservedMissing"><code>StructuralEquationModels.SemObservedMissing</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>For observed data with missing values.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">SemObservedMissing(;
    data,
    observed_vars = nothing,
    specification = nothing,
    kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>data</code>: observed data</li><li><code>observed_vars::Vector{Symbol}</code>: column names of the data (if the object passed as data does not have column names, i.e. is not a data frame)</li><li><code>specification</code>: optional SEM model specification (<a href="#StructuralEquationModels.SemSpecification"><code>SemSpecification</code></a>)</li></ul><p><strong>Extended help</strong></p><p><strong>Interfaces</strong></p><ul><li><p><code>nsamples(::SemObservedMissing)</code> -&gt; number of samples (data points)</p></li><li><p><code>nobserved_vars(::SemObservedMissing)</code> -&gt; number of observed variables</p></li><li><p><code>samples(::SemObservedMissing)</code> -&gt; data matrix (contains both measured and missing values)</p></li></ul><p><strong>Expectation maximization</strong></p><p><code>em_mvn!(::SemObservedMissing)</code> can be called to fit a covariance matrix and mean vector to the data using an expectation maximization (EM) algorithm under the assumption of multivariate normality. After, the following methods are available:</p><ul><li><code>em_model(::SemObservedMissing)</code> -&gt; <code>EmMVNModel</code> that contains the covariance matrix and mean vector found via EM</li><li><code>obs_cov(::SemObservedData)</code> -&gt; EM covariance matrix</li><li><code>obs_mean(::SemObservedData)</code> -&gt; EM mean vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/d0ff25b70ae22945cdc4315679a10efa97be64ad/src/observed/missing.jl#L16-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructuralEquationModels.samples" href="#StructuralEquationModels.samples"><code>StructuralEquationModels.samples</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">samples(observed::SemObservedData)</code></pre><p>Gets the matrix of observed data samples. Rows are samples, columns are observed variables.</p><p><strong>See Also</strong></p><p><a href="../inspection/inspection/#StructuralEquationModels.nsamples"><code>nsamples</code></a>, <a href="#StructuralEquationModels.observed_vars"><code>observed_vars</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/d0ff25b70ae22945cdc4315679a10efa97be64ad/src/observed/abstract.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructuralEquationModels.observed_vars" href="#StructuralEquationModels.observed_vars"><code>StructuralEquationModels.observed_vars</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">observed_vars(semobj) -&gt; Vector{Symbol}</code></pre><p>Return the vector of SEM model observed variable in the order specified by the model, which also should match the order of variables in <a href="#StructuralEquationModels.SemObserved"><code>SemObserved</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/d0ff25b70ae22945cdc4315679a10efa97be64ad/src/frontend/specification/documentation.jl#L11-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructuralEquationModels.SemSpecification" href="#StructuralEquationModels.SemSpecification"><code>StructuralEquationModels.SemSpecification</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Base type for all SEM specifications.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/d0ff25b70ae22945cdc4315679a10efa97be64ad/src/types.jl#L265-L267">source</a></section></article><h2 id="implied"><a class="docs-heading-anchor" href="#implied">implied</a><a id="implied-1"></a><a class="docs-heading-anchor-permalink" href="#implied" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructuralEquationModels.SemImplied" href="#StructuralEquationModels.SemImplied"><code>StructuralEquationModels.SemImplied</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Supertype of all objects that can serve as the implied field of a SEM. Computes model-implied values that should be compared with the observed data to find parameter estimates, e. g. the model implied covariance or mean. If you would like to implement a different notation, e.g. LISREL, you should implement a subtype of SemImplied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/d0ff25b70ae22945cdc4315679a10efa97be64ad/src/types.jl#L107-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructuralEquationModels.RAM" href="#StructuralEquationModels.RAM"><code>StructuralEquationModels.RAM</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Model implied covariance and means via RAM notation.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">RAM(;specification,
    meanstructure = false,
    gradient = true,
    kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>specification</code>: either a <code>RAMMatrices</code> or <code>ParameterTable</code> object</li><li><code>meanstructure::Bool</code>: does the model have a meanstructure?</li><li><code>gradient::Bool</code>: is gradient-based optimization used</li></ul><p><strong>Extended help</strong></p><p><strong>RAM notation</strong></p><p>The model implied covariance matrix is computed as</p><p class="math-container">\[    \Sigma = F(I-A)^{-1}S(I-A)^{-T}F^T\]</p><p>and for models with a meanstructure, the model implied means are computed as</p><p class="math-container">\[    \mu = F(I-A)^{-1}M\]</p><p><strong>Interfaces</strong></p><ul><li><p><code>param_labels(::RAM)</code>-&gt; vector of parameter labels</p></li><li><p><code>nparams(::RAM)</code> -&gt; number of parameters</p></li><li><p><code>ram.Σ</code> -&gt; model implied covariance matrix</p></li><li><p><code>ram.μ</code> -&gt; model implied mean vector</p></li></ul><p>RAM matrices for the current parameter values:</p><ul><li><code>ram.A</code></li><li><code>ram.S</code></li><li><code>ram.F</code></li><li><code>ram.M</code></li></ul><p>Jacobians of RAM matrices w.r.t to the parameter vector <code>θ</code></p><ul><li><code>ram.∇A</code> -&gt; <span>$∂vec(A)/∂θᵀ$</span></li><li><code>ram.∇S</code> -&gt; <span>$∂vec(S)/∂θᵀ$</span></li><li><code>ram.∇M</code> = <span>$∂M/∂θᵀ$</span></li></ul><p>Vector of indices of each parameter in the respective RAM matrix:</p><ul><li><code>ram.A_indices</code></li><li><code>ram.S_indices</code></li><li><code>ram.M_indices</code></li></ul><p>Additional interfaces</p><ul><li><code>ram.F⨉I_A⁻¹</code> -&gt; <span>$F(I-A)^{-1}$</span></li><li><code>ram.F⨉I_A⁻¹S</code> -&gt; <span>$F(I-A)^{-1}S$</span></li><li><code>ram.I_A</code> -&gt; <span>$I-A$</span></li></ul><p>Only available in gradient! calls:</p><ul><li><code>ram.I_A⁻¹</code> -&gt; <span>$(I-A)^{-1}$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/d0ff25b70ae22945cdc4315679a10efa97be64ad/src/implied/RAM/generic.jl#L4-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructuralEquationModels.RAMSymbolic" href="#StructuralEquationModels.RAMSymbolic"><code>StructuralEquationModels.RAMSymbolic</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Subtype of <code>SemImplied</code> that implements the RAM notation with symbolic precomputation.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">RAMSymbolic(;
    specification,
    vech = false,
    gradient = true,
    hessian = false,
    approximate_hessian = false,
    meanstructure = false,
    kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>specification</code>: either a <code>RAMMatrices</code> or <code>ParameterTable</code> object</li><li><code>meanstructure::Bool</code>: does the model have a meanstructure?</li><li><code>gradient::Bool</code>: is gradient-based optimization used</li><li><code>hessian::Bool</code>: is hessian-based optimization used</li><li><code>approximate_hessian::Bool</code>: for hessian based optimization: should the hessian be approximated</li><li><code>vech::Bool</code>: should the half-vectorization of Σ be computed (instead of the full matrix)   (automatically set to true if any of the loss functions is SemWLS)</li></ul><p><strong>Extended help</strong></p><p><strong>Interfaces</strong></p><ul><li><p><code>param_labels(::RAMSymbolic)</code>-&gt; vector of parameter ids</p></li><li><p><code>nparams(::RAMSymbolic)</code> -&gt; number of parameters</p></li><li><p><code>ram.Σ</code> -&gt; model implied covariance matrix</p></li><li><p><code>ram.μ</code> -&gt; model implied mean vector</p></li></ul><p>Jacobians (only available in gradient! calls)</p><ul><li><p><code>ram.∇Σ</code> -&gt; <span>$∂vec(Σ)/∂θᵀ$</span></p></li><li><p><code>ram.∇μ</code> -&gt; <span>$∂μ/∂θᵀ$</span></p></li><li><p><code>ram.∇Σ_function</code> -&gt; function to overwrite <code>∇Σ</code> in place,   i.e. <code>∇Σ_function(∇Σ, θ)</code>. Typically, you do not want to use this but simply   query <code>ram.∇Σ</code>.</p></li></ul><p>Hessians The computation of hessians is more involved. Therefore, we desribe it in the online documentation,  and the respective interfaces are omitted here.</p><p><strong>RAM notation</strong></p><p>The model implied covariance matrix is computed as</p><p class="math-container">\[    \Sigma = F(I-A)^{-1}S(I-A)^{-T}F^T\]</p><p>and for models with a meanstructure, the model implied means are computed as</p><p class="math-container">\[    \mu = F(I-A)^{-1}M\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/d0ff25b70ae22945cdc4315679a10efa97be64ad/src/implied/RAM/symbolic.jl#L4-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructuralEquationModels.ImpliedEmpty" href="#StructuralEquationModels.ImpliedEmpty"><code>StructuralEquationModels.ImpliedEmpty</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Empty placeholder for models that don&#39;t need an implied part. (For example, models that only regularize parameters.)</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">ImpliedEmpty(;specification, kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>specification</code>: either a <code>RAMMatrices</code> or <code>ParameterTable</code> object</li></ul><p><strong>Examples</strong></p><p>A multigroup model with ridge regularization could be specified as a <code>SemEnsemble</code> with one model per group and an additional model with <code>ImpliedEmpty</code> and <code>SemRidge</code> for the regularization part.</p><p><strong>Extended help</strong></p><p><strong>Interfaces</strong></p><ul><li><code>param_labels(::ImpliedEmpty)</code>-&gt; Vector of parameter labels</li><li><code>nparams(::ImpliedEmpty)</code> -&gt; Number of parameters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/d0ff25b70ae22945cdc4315679a10efa97be64ad/src/implied/empty.jl#L4-L24">source</a></section></article><h2 id="loss-functions"><a class="docs-heading-anchor" href="#loss-functions">loss functions</a><a id="loss-functions-1"></a><a class="docs-heading-anchor-permalink" href="#loss-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructuralEquationModels.SemLoss" href="#StructuralEquationModels.SemLoss"><code>StructuralEquationModels.SemLoss</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SemLoss(args...; loss_weights = nothing, ...)</code></pre><p>Constructs the loss field of a SEM. Can contain multiple <code>SemLossFunction</code>s, the model is optimized over their sum. See also <a href="#StructuralEquationModels.SemLossFunction"><code>SemLossFunction</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>args...</code>: Multiple <code>SemLossFunction</code>s.</li><li><code>loss_weights::Vector</code>: Weights for each loss function. Defaults to unweighted optimization.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">my_ml_loss = SemML(...)
my_ridge_loss = SemRidge(...)
my_loss = SemLoss(SemML, SemRidge; loss_weights = [1.0, 2.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/d0ff25b70ae22945cdc4315679a10efa97be64ad/src/types.jl#L42-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructuralEquationModels.SemLossFunction" href="#StructuralEquationModels.SemLossFunction"><code>StructuralEquationModels.SemLossFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Supertype for all loss functions of SEMs. If you want to implement a custom loss function, it should be a subtype of <code>SemLossFunction</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/d0ff25b70ae22945cdc4315679a10efa97be64ad/src/types.jl#L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructuralEquationModels.SemML" href="#StructuralEquationModels.SemML"><code>StructuralEquationModels.SemML</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Maximum likelihood estimation.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">SemML(;observed, meanstructure = false, approximate_hessian = false, kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>observed::SemObserved</code>: the observed part of the model</li><li><code>meanstructure::Bool</code>: does the model have a meanstructure?</li><li><code>approximate_hessian::Bool</code>: if hessian-based optimization is used, should the hessian be swapped for an approximation</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">my_ml = SemML(observed = my_observed)</code></pre><p><strong>Interfaces</strong></p><p>Analytic gradients are available, and for models without a meanstructure and RAMSymbolic implied type, also analytic hessians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/d0ff25b70ae22945cdc4315679a10efa97be64ad/src/loss/ML/ML.jl#L6-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructuralEquationModels.SemFIML" href="#StructuralEquationModels.SemFIML"><code>StructuralEquationModels.SemFIML</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Full information maximum likelihood estimation. Can handle observed data with missings.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">SemFIML(;observed, specification, kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>observed::SemObservedMissing</code>: the observed part of the model</li><li><code>specification</code>: either a <code>RAMMatrices</code> or <code>ParameterTable</code> object</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">my_fiml = SemFIML(observed = my_observed, specification = my_parameter_table)</code></pre><p><strong>Interfaces</strong></p><p>Analytic gradients are available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/d0ff25b70ae22945cdc4315679a10efa97be64ad/src/loss/ML/FIML.jl#L4-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructuralEquationModels.SemWLS" href="#StructuralEquationModels.SemWLS"><code>StructuralEquationModels.SemWLS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Weighted least squares estimation. At the moment only available with the <code>RAMSymbolic</code> implied type.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">SemWLS(;
    observed,
    meanstructure = false,
    wls_weight_matrix = nothing,
    wls_weight_matrix_mean = nothing,
    approximate_hessian = false,
    kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>observed</code>: the <code>SemObserved</code> part of the model</li><li><code>meanstructure::Bool</code>: does the model have a meanstructure?</li><li><code>approximate_hessian::Bool</code>: should the hessian be swapped for an approximation</li><li><code>wls_weight_matrix</code>: the weight matrix for weighted least squares.   Defaults to GLS estimation (<span>$0.5*(D^T*kron(S,S)*D)$</span> where D is the duplication matrix   and S is the inverse of the observed covariance matrix)</li><li><code>wls_weight_matrix_mean</code>: the weight matrix for the mean part of weighted least squares.   Defaults to GLS estimation (the inverse of the observed covariance matrix)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">my_wls = SemWLS(observed = my_observed)</code></pre><p><strong>Interfaces</strong></p><p>Analytic gradients are available, and for models without a meanstructure also analytic hessians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/d0ff25b70ae22945cdc4315679a10efa97be64ad/src/loss/WLS/WLS.jl#L6-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructuralEquationModels.SemRidge" href="#StructuralEquationModels.SemRidge"><code>StructuralEquationModels.SemRidge</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Ridge regularization.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">SemRidge(;α_ridge, which_ridge, nparams, parameter_type = Float64, implied = nothing, kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>α_ridge</code>: hyperparameter for penalty term</li><li><code>which_ridge::Vector</code>: Vector of parameter labels (Symbols) or indices that indicate which parameters should be regularized.</li><li><code>nparams::Int</code>: number of parameters of the model</li><li><code>implied::SemImplied</code>: implied part of the model</li><li><code>parameter_type</code>: type of the parameters</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">my_ridge = SemRidge(;α_ridge = 0.02, which_ridge = [:λ₁, :λ₂, :ω₂₃], nparams = 30, implied = my_implied)</code></pre><p><strong>Interfaces</strong></p><p>Analytic gradients and hessians are available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/d0ff25b70ae22945cdc4315679a10efa97be64ad/src/loss/regularization/ridge.jl#L6-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructuralEquationModels.SemConstant" href="#StructuralEquationModels.SemConstant"><code>StructuralEquationModels.SemConstant</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Constant loss term. Can be used for comparability to other packages.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">SemConstant(;constant_loss, kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>constant_loss::Number</code>: constant to add to the objective</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">    my_constant = SemConstant(constant_loss = 42.0)</code></pre><p><strong>Interfaces</strong></p><p>Analytic gradients and hessians are available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/d0ff25b70ae22945cdc4315679a10efa97be64ad/src/loss/constant/constant.jl#L6-L23">source</a></section></article><h2 id="optimizer"><a class="docs-heading-anchor" href="#optimizer">optimizer</a><a id="optimizer-1"></a><a class="docs-heading-anchor-permalink" href="#optimizer" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructuralEquationModels.SemOptimizer" href="#StructuralEquationModels.SemOptimizer"><code>StructuralEquationModels.SemOptimizer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Supertype of all objects that can serve as the <code>optimizer</code> field of a SEM. Connects the SEM to its optimization backend and controls options like the optimization algorithm. If you want to connect the SEM package to a new optimization backend, you should implement a subtype of SemOptimizer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/d0ff25b70ae22945cdc4315679a10efa97be64ad/src/types.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructuralEquationModels.SemOptimizerOptim" href="#StructuralEquationModels.SemOptimizerOptim"><code>StructuralEquationModels.SemOptimizerOptim</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SemOptimizerOptim{A, B} &lt;: SemOptimizer{:Optim}</code></pre><p>Connects to <code>Optim.jl</code> as the optimization backend.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">SemOptimizerOptim(;
    algorithm = LBFGS(),
    options = Optim.Options(;f_reltol = 1e-10, x_abstol = 1.5e-8),
    kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>algorithm</code>: optimization algorithm from <code>Optim.jl</code></li><li><code>options::Optim.Options</code>: options for the optimization algorithm</li></ul><p><strong>Usage</strong></p><p>All algorithms and options from the Optim.jl library are available, for more information see the Optim.jl online documentation.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">my_optimizer = SemOptimizerOptim()

# hessian based optimization with backtracking linesearch and modified initial step size
using Optim, LineSearches

my_newton_optimizer = SemOptimizerOptim(
    algorithm = Newton(
        ;linesearch = BackTracking(order=3),
        alphaguess = InitialHagerZhang()
    )
)</code></pre><p><strong>Extended help</strong></p><p><strong>Constrained optimization</strong></p><p>When using the <code>Fminbox</code> or <code>SAMIN</code> constrained optimization algorithms, the vector or dictionary of lower and upper bounds for each model parameter can be specified via <code>lower_bounds</code> and <code>upper_bounds</code> keyword arguments. Alternatively, the <code>lower_bound</code> and <code>upper_bound</code> keyword arguments can be used to specify the default bound for all non-variance model parameters, and the <code>variance_lower_bound</code> and <code>variance_upper_bound</code> keyword – for the variance parameters (the diagonal of the <em>S</em> matrix).</p><p><strong>Interfaces</strong></p><ul><li><code>algorithm(::SemOptimizerOptim)</code></li><li><code>options(::SemOptimizerOptim)</code></li></ul><p><strong>Implementation</strong></p><p>Subtype of <code>SemOptimizer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/d0ff25b70ae22945cdc4315679a10efa97be64ad/src/optimizer/optim.jl#L6-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructuralEquationModels.SemOptimizerNLopt" href="#StructuralEquationModels.SemOptimizerNLopt"><code>StructuralEquationModels.SemOptimizerNLopt</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Connects to <code>NLopt.jl</code> as the optimization backend. Only usable if <code>NLopt.jl</code> is loaded in the current Julia session!</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">SemOptimizerNLopt(;
    algorithm = :LD_LBFGS,
    options = Dict{Symbol, Any}(),
    local_algorithm = nothing,
    local_options = Dict{Symbol, Any}(),
    equality_constraints = Vector{NLoptConstraint}(),
    inequality_constraints = Vector{NLoptConstraint}(),
    kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>algorithm</code>: optimization algorithm.</li><li><code>options::Dict{Symbol, Any}</code>: options for the optimization algorithm</li><li><code>local_algorithm</code>: local optimization algorithm</li><li><code>local_options::Dict{Symbol, Any}</code>: options for the local optimization algorithm</li><li><code>equality_constraints::Vector{NLoptConstraint}</code>: vector of equality constraints</li><li><code>inequality_constraints::Vector{NLoptConstraint}</code>: vector of inequality constraints</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">my_optimizer = SemOptimizerNLopt()

# constrained optimization with augmented lagrangian
my_constrained_optimizer = SemOptimizerNLopt(;
    algorithm = :AUGLAG,
    local_algorithm = :LD_LBFGS,
    local_options = Dict(:ftol_rel =&gt; 1e-6),
    inequality_constraints = NLoptConstraint(;f = my_constraint, tol = 0.0),
)</code></pre><p><strong>Usage</strong></p><p>All algorithms and options from the NLopt library are available, for more information see the NLopt.jl package and the NLopt online documentation. For information on how to use inequality and equality constraints, see <a href="../constraints/constraints/#Constrained-optimization">Constrained optimization</a> in our online documentation.</p><p><strong>Extended help</strong></p><p><strong>Interfaces</strong></p><ul><li><code>algorithm(::SemOptimizerNLopt)</code></li><li><code>local_algorithm(::SemOptimizerNLopt)</code></li><li><code>options(::SemOptimizerNLopt)</code></li><li><code>local_options(::SemOptimizerNLopt)</code></li><li><code>equality_constraints(::SemOptimizerNLopt)</code></li><li><code>inequality_constraints(::SemOptimizerNLopt)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/d0ff25b70ae22945cdc4315679a10efa97be64ad/src/package_extensions/SEMNLOptExt.jl#L1-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructuralEquationModels.SemOptimizerProximal" href="#StructuralEquationModels.SemOptimizerProximal"><code>StructuralEquationModels.SemOptimizerProximal</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Connects to <code>ProximalAlgorithms.jl</code> as the optimization backend. Can be used for regularized SEM, for a tutorial see the online docs on <a href="../regularization/regularization/#Regularization">Regularization</a>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">SemOptimizerProximal(;
    algorithm = ProximalAlgorithms.PANOC(),
    operator_g,
    operator_h = nothing,
    kwargs...,</code></pre><p><strong>Arguments</strong></p><ul><li><code>algorithm</code>: optimization algorithm.</li><li><code>operator_g</code>: proximal operator (e.g., regularization penalty)</li><li><code>operator_h</code>: optional second proximal operator</li></ul><p><strong>Usage</strong></p><p>All algorithms and operators from <code>ProximalAlgorithms.jl</code> are available, for more information see the online docs on <a href="../regularization/regularization/#Regularization">Regularization</a> and the documentation of <code>ProximalAlgorithms.jl</code> / <code>ProximalOperators.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/d0ff25b70ae22945cdc4315679a10efa97be64ad/src/package_extensions/SEMProximalOptExt.jl#L1-L22">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../first_model/">« A first model</a><a class="docs-footer-nextpage" href="../specification/specification/">Model specification »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Wednesday 16 April 2025 15:08">Wednesday 16 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
