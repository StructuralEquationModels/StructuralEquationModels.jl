# generate sparse matrix with 1 in each row
function eachrow_to_col(
    ::Type{T},
    column_indices::AbstractVector{Int},
    ncolumns::Integer,
) where {T}
    nrows = length(column_indices)
    (nrows > ncolumns) && throw(
        DimensionMismatch(
            "The number of rows ($nrows) cannot exceed the number of columns ($ncolumns)",
        ),
    )
    all(i -> 1 <= i <= ncolumns, column_indices) ||
        throw(ArgumentError("All column indices must be between 1 and $ncolumns"))

    sparse(eachindex(column_indices), column_indices, ones(T, nrows), nrows, ncolumns)
end

eachrow_to_col(column_indices::AbstractVector{Int}, ncolumns::Integer) =
    eachrow_to_col(Float64, column_indices, ncolumns)

# generate sparse matrix with 1 in each column
function eachcol_to_row(
    ::Type{T},
    row_indices::AbstractVector{Int},
    nrows::Integer,
) where {T}
    ncols = length(row_indices)
    (ncols > nrows) && throw(
        DimensionMismatch(
            "The number of columns ($ncols) cannot exceed the number of rows ($nrows)",
        ),
    )
    all(i -> 1 <= i <= nrows, row_indices) ||
        throw(ArgumentError("All row indices must be between 1 and $nrows"))

    sparse(row_indices, eachindex(row_indices), ones(T, ncols), nrows, ncols)
end

eachcol_to_row(row_indices::AbstractVector{Int}, nrows::Integer) =
    eachcol_to_row(Float64, row_indices, nrows)

# non-zero indices of columns in matrix A generated by eachrow_to_col()
# if order == :rows, then the indices are in the order of the rows,
# if order == :columns, the indices are in the order of the columns
function nzcols_eachrow_to_col(F, A::SparseMatrixCSC; order::Symbol = :rows)
    order âˆˆ [:rows, :columns] || throw(ArgumentError("order must be :rows or :columns"))
    T = typeof(F(1))
    res = Vector{T}(undef, size(A, 1))
    n = 0
    for i in 1:size(A, 2)
        colptr = A.colptr[i]
        next_colptr = A.colptr[i+1]
        if next_colptr > colptr # non-zero
            @assert next_colptr - colptr == 1
            n += 1
            res[order == :rows ? A.rowval[colptr] : n] = F(i)
        end
    end
    @assert n == size(A, 1)
    return res
end

nzcols_eachrow_to_col(A::SparseMatrixCSC; order::Symbol = :rows) =
    nzcols_eachrow_to_col(identity, A, order = order)

# same as nzcols_eachrow_to_col()
# but without assumption that each row cooresponds to exactly one column
# the order is always columns order
function nzcols(F, A::SparseMatrixCSC)
    T = typeof(F(1))
    res = Vector{T}()
    for i in 1:size(A, 2)
        colptr = A.colptr[i]
        next_colptr = A.colptr[i+1]
        if next_colptr > colptr # non-zero
            push!(res, F(i))
        end
    end
    return res
end

nzcols(A::SparseMatrixCSC) = nzcols(identity, A)
