<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Our Concept of a Structural Equation Model · StructuralEquationModels.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon_zeta.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="StructuralEquationModels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">StructuralEquationModels.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">A fast and flexible SEM framework</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../first_model/">A first model</a></li><li class="is-active"><a class="tocitem" href>Our Concept of a Structural Equation Model</a><ul class="internal"><li><a class="tocitem" href="#The-observed-part-aka-[SemObserved](@ref)"><span>The observed part aka <code>SemObserved</code></span></a></li><li><a class="tocitem" href="#The-imply-part-aka-[SemImply](@ref)"><span>The imply part aka <code>SemImply</code></span></a></li><li><a class="tocitem" href="#The-loss-part-aka-SemLoss"><span>The loss part aka <code>SemLoss</code></span></a></li><li><a class="tocitem" href="#The-optimizer-part-aka-SemOptimizer"><span>The optimizer part aka <code>SemOptimizer</code></span></a></li><li class="toplevel"><a class="tocitem" href="#What-to-do-next"><span>What to do next</span></a></li><li class="toplevel"><a class="tocitem" href="#API-model-parts"><span>API - model parts</span></a></li><li><a class="tocitem" href="#observed"><span>observed</span></a></li><li><a class="tocitem" href="#imply"><span>imply</span></a></li><li><a class="tocitem" href="#loss-functions"><span>loss functions</span></a></li><li><a class="tocitem" href="#optimizer"><span>optimizer</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Model Specification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../specification/specification/">Model specification</a></li><li><a class="tocitem" href="../specification/graph_interface/">Graph interface</a></li><li><a class="tocitem" href="../specification/ram_matrices/">RAMMatrices interface</a></li><li><a class="tocitem" href="../specification/parameter_table/">ParameterTable interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Model Construction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../construction/construction/">Model Construction</a></li><li><a class="tocitem" href="../construction/outer_constructor/">Outer Constructor</a></li><li><a class="tocitem" href="../construction/build_by_parts/">Build by parts</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Optimization Backends</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../backends/optim/">Using Optim.jl</a></li><li><a class="tocitem" href="../backends/nlopt/">Using NLopt.jl</a></li></ul></li><li><a class="tocitem" href="../fitting/fitting/">Model Fitting</a></li><li><a class="tocitem" href="../inspection/inspection/">Model Inspection</a></li><li><a class="tocitem" href="../meanstructure/">Mean Structures</a></li><li><input class="collapse-toggle" id="menuitem-2-9" type="checkbox"/><label class="tocitem" for="menuitem-2-9"><span class="docs-label">Collections</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../collection/collection/">Collections</a></li><li><a class="tocitem" href="../collection/multigroup/">Multigroup models</a></li></ul></li><li><a class="tocitem" href="../constraints/constraints/">Constraints</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Developer documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../developer/extending/">Extending the package</a></li><li><a class="tocitem" href="../../developer/loss/">Custom loss functions</a></li><li><a class="tocitem" href="../../developer/imply/">Custom imply types</a></li><li><a class="tocitem" href="../../developer/optimizer/">Custom optimizer types</a></li><li><a class="tocitem" href="../../developer/observed/">Custom observed types</a></li><li><a class="tocitem" href="../../developer/sem/">Custom model types</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Advanced tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../regularization/regularization/">Regularization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Performance tips</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../performance/sorting/">Model sorting</a></li><li><a class="tocitem" href="../../performance/mkl/">MKL</a></li><li><a class="tocitem" href="../../performance/simulation/">Simulation studies</a></li><li><a class="tocitem" href="../../performance/symbolic/">Symbolic precomputation</a></li><li><a class="tocitem" href="../../performance/starting_values/">Starting values</a></li><li><a class="tocitem" href="../../performance/parametric/">Parametric Types</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Internals and design</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../internals/internals/">Internals and design</a></li><li><a class="tocitem" href="../../internals/files/">files</a></li><li><a class="tocitem" href="../../internals/types/">types</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Complementary material</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../complementary/maths/">Mathematical appendix</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Our Concept of a Structural Equation Model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Our Concept of a Structural Equation Model</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/main/docs/src/tutorials/concept.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Our-Concept-of-a-Structural-Equation-Model"><a class="docs-heading-anchor" href="#Our-Concept-of-a-Structural-Equation-Model">Our Concept of a Structural Equation Model</a><a id="Our-Concept-of-a-Structural-Equation-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Our-Concept-of-a-Structural-Equation-Model" title="Permalink"></a></h1><p>In our package, every Structural Equation Model (<code>Sem</code>) consists of four parts:</p><p><img src="../../assets/concept.svg" alt="SEM concept"/></p><p>Those parts are interchangable building blocks (like &#39;Legos&#39;), i.e. there are different pieces available you can choose as the &#39;observed&#39; slot of the model, and stick them together with other pieces that can serve as the &#39;imply&#39; part.</p><p>The &#39;observed&#39; part is for observed data, the imply part is what the model implies about your data (e.g. the model implied covariance matrix), the loss part compares the observed data and implied properties (e.g. weighted least squares difference between the observed and implied covariance matrix) and the optimizer part connects to the optimization backend (e.g. the type of optimization algorithm used).</p><p>For example, to build a model for maximum likelihood estimation with the NLopt optimization suite as a backend you would choose <code>SemML</code> as a loss function and <code>SemOptimizerNLopt</code> as the optimizer.</p><p>As you can see, a model can have as many loss functions as you want it to have. We always optimize over their (weighted) sum. So to build a model for ridge regularized full information maximum likelihood estimation, you would choose two loss functions, <code>SemFIML</code> and <code>SemRidge</code>.</p><p>In julia, everything has a type. To make more precise which objects can be used as the different building blocks, we require them to have a certain type:</p><p><img src="../../assets/concept_typed.svg" alt="SEM concept typed"/></p><p>So everything that can be used as the &#39;observed&#39; part has to be of type <code>SemObserved</code>.</p><p>Here is an overview on the available building blocks:</p><table><tr><th style="text-align: right"><a href="#StructuralEquationModels.SemObserved"><code>SemObserved</code></a></th><th style="text-align: right"><a href="#StructuralEquationModels.SemImply"><code>SemImply</code></a></th><th style="text-align: right"><a href="#StructuralEquationModels.SemLossFunction"><code>SemLossFunction</code></a></th><th style="text-align: right"><a href="#StructuralEquationModels.SemOptimizer"><code>SemOptimizer</code></a></th></tr><tr><td style="text-align: right"><a href="#StructuralEquationModels.SemObservedData"><code>SemObservedData</code></a></td><td style="text-align: right"><a href="#StructuralEquationModels.RAM"><code>RAM</code></a></td><td style="text-align: right"><a href="#StructuralEquationModels.SemML"><code>SemML</code></a></td><td style="text-align: right"><a href="#StructuralEquationModels.SemOptimizerOptim"><code>SemOptimizerOptim</code></a></td></tr><tr><td style="text-align: right"><a href="#StructuralEquationModels.SemObservedCovariance"><code>SemObservedCovariance</code></a></td><td style="text-align: right"><a href="#StructuralEquationModels.RAMSymbolic"><code>RAMSymbolic</code></a></td><td style="text-align: right"><a href="#StructuralEquationModels.SemWLS"><code>SemWLS</code></a></td><td style="text-align: right"><a href="#StructuralEquationModels.SemOptimizerNLopt"><code>SemOptimizerNLopt</code></a></td></tr><tr><td style="text-align: right"><a href="#StructuralEquationModels.SemObservedMissing"><code>SemObservedMissing</code></a></td><td style="text-align: right"><a href="#StructuralEquationModels.ImplyEmpty"><code>ImplyEmpty</code></a></td><td style="text-align: right"><a href="#StructuralEquationModels.SemFIML"><code>SemFIML</code></a></td><td style="text-align: right"></td></tr><tr><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"><a href="#StructuralEquationModels.SemRidge"><code>SemRidge</code></a></td><td style="text-align: right"></td></tr><tr><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"><a href="#StructuralEquationModels.SemConstant"><code>SemConstant</code></a></td><td style="text-align: right"></td></tr></table><p>The rest of this page explains the building blocks for each part. First, we explain every part and give an overview on the different options that are available. After that, the <a href="#API-model-parts">API - model parts</a> section serves as a reference for detailed explanations about the different options. (How to stick them together to a final model is explained in the section on <a href="tutorials/@ref">Model construction</a>.)</p><h2 id="The-observed-part-aka-[SemObserved](@ref)"><a class="docs-heading-anchor" href="#The-observed-part-aka-[SemObserved](@ref)">The observed part aka <a href="#StructuralEquationModels.SemObserved"><code>SemObserved</code></a></a><a id="The-observed-part-aka-[SemObserved](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#The-observed-part-aka-[SemObserved](@ref)" title="Permalink"></a></h2><p>The &#39;observed&#39; part contains all necessary information about the observed data. Currently, we have three options: <a href="#StructuralEquationModels.SemObservedData"><code>SemObservedData</code></a> for fully observed datasets, <a href="#StructuralEquationModels.SemObservedCovariance"><code>SemObservedCovariance</code></a> for observed covariances (and means) and <a href="#StructuralEquationModels.SemObservedMissing"><code>SemObservedMissing</code></a> for data that contains missing values.</p><h2 id="The-imply-part-aka-[SemImply](@ref)"><a class="docs-heading-anchor" href="#The-imply-part-aka-[SemImply](@ref)">The imply part aka <a href="#StructuralEquationModels.SemImply"><code>SemImply</code></a></a><a id="The-imply-part-aka-[SemImply](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#The-imply-part-aka-[SemImply](@ref)" title="Permalink"></a></h2><p>The imply part is what your model implies about the data, for example, the model-implied covariance matrix.  There are two options at the moment: <a href="#StructuralEquationModels.RAM"><code>RAM</code></a>, which uses the reticular action model to compute the model implied covariance matrix, and <a href="#StructuralEquationModels.RAMSymbolic"><code>RAMSymbolic</code></a> which does the same but symbolically pre-computes part of the model, which increases subsequent performance in model fitting (see <a href="../../performance/symbolic/#Symbolic-precomputation">Symbolic precomputation</a>). There is also a third option, <a href="#StructuralEquationModels.ImplyEmpty"><code>ImplyEmpty</code></a> that can serve as a &#39;placeholder&#39; for models that do not need an imply part.</p><h2 id="The-loss-part-aka-SemLoss"><a class="docs-heading-anchor" href="#The-loss-part-aka-SemLoss">The loss part aka <code>SemLoss</code></a><a id="The-loss-part-aka-SemLoss-1"></a><a class="docs-heading-anchor-permalink" href="#The-loss-part-aka-SemLoss" title="Permalink"></a></h2><p>The loss part specifies the objective that is optimized to find the parameter estimates. If it contains more then one loss function (aka <a href="#StructuralEquationModels.SemLossFunction"><code>SemLossFunction</code></a>)), we find the parameters by minimizing the sum of loss functions (for example in maximum likelihood estimation + ridge regularization). Available loss functions are</p><ul><li><a href="#StructuralEquationModels.SemML"><code>SemML</code></a>: maximum likelihood estimation</li><li><a href="#StructuralEquationModels.SemWLS"><code>SemWLS</code></a>: weighted least squares estimation</li><li><a href="#StructuralEquationModels.SemFIML"><code>SemFIML</code></a>: full-information maximum likelihood estimation</li><li><a href="#StructuralEquationModels.SemRidge"><code>SemRidge</code></a>: ridge regularization</li></ul><h2 id="The-optimizer-part-aka-SemOptimizer"><a class="docs-heading-anchor" href="#The-optimizer-part-aka-SemOptimizer">The optimizer part aka <code>SemOptimizer</code></a><a id="The-optimizer-part-aka-SemOptimizer-1"></a><a class="docs-heading-anchor-permalink" href="#The-optimizer-part-aka-SemOptimizer" title="Permalink"></a></h2><p>The optimizer part of a model connects to the numerical optimization backend used to fit the model.  It can be used to control options like the optimization algorithm, linesearch, stopping criteria, etc.  There are currently two available backends, <a href="#StructuralEquationModels.SemOptimizerOptim"><code>SemOptimizerOptim</code></a> connecting to the <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a> backend, and <a href="#StructuralEquationModels.SemOptimizerNLopt"><code>SemOptimizerNLopt</code></a> connecting to the <a href="https://github.com/JuliaOpt/NLopt.jl">NLopt.jl</a> backend. For more information about the available options see also the tutorials about <a href="../backends/optim/#Using-Optim.jl">Using Optim.jl</a> and <a href="../backends/nlopt/#Using-NLopt.jl">Using NLopt.jl</a>, as well as <a href="../constraints/constraints/#Constrained-optimization">Constrained optimization</a>.</p><h1 id="What-to-do-next"><a class="docs-heading-anchor" href="#What-to-do-next">What to do next</a><a id="What-to-do-next-1"></a><a class="docs-heading-anchor-permalink" href="#What-to-do-next" title="Permalink"></a></h1><p>You now have an understanding about our representation of structural equation models.</p><p>To learn more about how to use the package, you may visit the remaining tutorials.</p><p>If you want to learn how to extend the package (e.g., add a new loss function), you may visit <a href="../../developer/extending/#Extending-the-package">Extending the package</a>.</p><h1 id="API-model-parts"><a class="docs-heading-anchor" href="#API-model-parts">API - model parts</a><a id="API-model-parts-1"></a><a class="docs-heading-anchor-permalink" href="#API-model-parts" title="Permalink"></a></h1><h2 id="observed"><a class="docs-heading-anchor" href="#observed">observed</a><a id="observed-1"></a><a class="docs-heading-anchor-permalink" href="#observed" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StructuralEquationModels.SemObserved" href="#StructuralEquationModels.SemObserved"><code>StructuralEquationModels.SemObserved</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype of all objects that can serve as the observed field of a SEM. Pre-processes data and computes sufficient statistics for example. If you have a special kind of data, e.g. ordinal data, you should implement a subtype of SemObserved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/e0ce63c24e7eb8508c35d06948194cca50d4afb4/src/types.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StructuralEquationModels.SemObservedData" href="#StructuralEquationModels.SemObservedData"><code>StructuralEquationModels.SemObservedData</code></a> — <span class="docstring-category">Type</span></header><section><div><p>For observed data without missings.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">SemObservedData(;
    specification,
    data,
    meanstructure = false,
    obs_colnames = nothing,
    kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>specification</code>: either a <code>RAMMatrices</code> or <code>ParameterTable</code> object (1)</li><li><code>data</code>: observed data</li><li><code>meanstructure::Bool</code>: does the model have a meanstructure?</li><li><code>obs_colnames::Vector{Symbol}</code>: column names of the data (if the object passed as data does not have column names, i.e. is not a data frame)</li></ul><p><strong>Extended help</strong></p><p><strong>Interfaces</strong></p><ul><li><p><code>n_obs(::SemObservedData)</code> -&gt; number of observed data points</p></li><li><p><code>n_man(::SemObservedData)</code> -&gt; number of manifest variables</p></li><li><p><code>get_data(::SemObservedData)</code> -&gt; observed data</p></li><li><p><code>obs_cov(::SemObservedData)</code> -&gt; observed.obs_cov</p></li><li><p><code>obs_mean(::SemObservedData)</code> -&gt; observed.obs_mean</p></li><li><p><code>data_rowwise(::SemObservedData)</code> -&gt; observed data, stored as vectors per observation</p></li></ul><p><strong>Implementation</strong></p><p>Subtype of <code>SemObserved</code></p><p><strong>Remarks</strong></p><p>(1) the <code>specification</code> argument can also be <code>nothing</code>, but this turns of checking whether the observed data/covariance columns are in the correct order! As a result, you should only use this if you are sure your observed data is in the right format.</p><p><strong>Additional keyword arguments:</strong></p><ul><li><code>spec_colnames::Vector{Symbol} = nothing</code>: overwrites column names of the specification object</li><li><code>compute_covariance::Bool ) = true</code>: should the covariance of <code>data</code> be computed and stored?</li><li><code>rowwise::Bool = false</code>: should the data be stored also as vectors per observation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/e0ce63c24e7eb8508c35d06948194cca50d4afb4/src/observed/data.jl#L1-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StructuralEquationModels.SemObservedCovariance" href="#StructuralEquationModels.SemObservedCovariance"><code>StructuralEquationModels.SemObservedCovariance</code></a> — <span class="docstring-category">Type</span></header><section><div><p>For observed covariance matrices and means.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">SemObservedCovariance(;
    specification,
    obs_cov,
    obs_colnames = nothing,
    meanstructure = false,
    obs_mean = nothing,
    n_obs = nothing,
    kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>specification</code>: either a <code>RAMMatrices</code> or <code>ParameterTable</code> object (1)</li><li><code>obs_cov</code>: observed covariance matrix</li><li><code>obs_colnames::Vector{Symbol}</code>: column names of the covariance matrix</li><li><code>meanstructure::Bool</code>: does the model have a meanstructure?</li><li><code>obs_mean</code>: observed mean vector</li><li><code>n_obs::Number</code>: number of observed data points (necessary for fit statistics)</li></ul><p><strong>Extended help</strong></p><p><strong>Interfaces</strong></p><ul><li><p><code>n_obs(::SemObservedCovariance)</code> -&gt; number of observed data points</p></li><li><p><code>n_man(::SemObservedCovariance)</code> -&gt; number of manifest variables</p></li><li><p><code>obs_cov(::SemObservedCovariance)</code> -&gt; observed covariance matrix</p></li><li><p><code>obs_mean(::SemObservedCovariance)</code> -&gt; observed means</p></li></ul><p><strong>Implementation</strong></p><p>Subtype of <code>SemObserved</code></p><p><strong>Remarks</strong></p><p>(1) the <code>specification</code> argument can also be <code>nothing</code>, but this turns of checking whether the observed data/covariance columns are in the correct order! As a result, you should only use this if you are sure your covariance matrix is in the right format.</p><p><strong>Additional keyword arguments:</strong></p><ul><li><code>spec_colnames::Vector{Symbol} = nothing</code>: overwrites column names of the specification object</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/e0ce63c24e7eb8508c35d06948194cca50d4afb4/src/observed/covariance.jl#L1-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StructuralEquationModels.SemObservedMissing" href="#StructuralEquationModels.SemObservedMissing"><code>StructuralEquationModels.SemObservedMissing</code></a> — <span class="docstring-category">Type</span></header><section><div><p>For observed data with missing values.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">SemObservedMissing(;
    specification,
    data,
    obs_colnames = nothing,
    kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>specification</code>: either a <code>RAMMatrices</code> or <code>ParameterTable</code> object (1)</li><li><code>data</code>: observed data</li><li><code>obs_colnames::Vector{Symbol}</code>: column names of the data (if the object passed as data does not have column names, i.e. is not a data frame)</li></ul><p><strong>Extended help</strong></p><p><strong>Interfaces</strong></p><ul><li><p><code>n_obs(::SemObservedMissing)</code> -&gt; number of observed data points</p></li><li><p><code>n_man(::SemObservedMissing)</code> -&gt; number of manifest variables</p></li><li><p><code>get_data(::SemObservedMissing)</code> -&gt; observed data</p></li><li><p><code>data_rowwise(::SemObservedMissing)</code> -&gt; observed data as vector per observation, with missing values deleted</p></li><li><p><code>patterns(::SemObservedMissing)</code> -&gt; indices of non-missing variables per missing patterns </p></li><li><p><code>patterns_not(::SemObservedMissing)</code> -&gt; indices of missing variables per missing pattern</p></li><li><p><code>rows(::SemObservedMissing)</code> -&gt; row indices of observed data points that belong to each pattern</p></li><li><p><code>pattern_n_obs(::SemObservedMissing)</code> -&gt; number of data points per pattern</p></li><li><p><code>pattern_nvar_obs(::SemObservedMissing)</code> -&gt; number of non-missing observed variables per pattern</p></li><li><p><code>obs_mean(::SemObservedMissing)</code> -&gt; observed mean per pattern</p></li><li><p><code>obs_cov(::SemObservedMissing)</code> -&gt; observed covariance per pattern</p></li><li><p><code>em_model(::SemObservedMissing)</code> -&gt; <code>EmMVNModel</code> that contains the covariance matrix and mean vector found via optimization maximization</p></li></ul><p><strong>Implementation</strong></p><p>Subtype of <code>SemObserved</code></p><p><strong>Remarks</strong></p><p>(1) the <code>specification</code> argument can also be <code>nothing</code>, but this turns of checking whether the observed data/covariance columns are in the correct order! As a result, you should only use this if you are sure your observed data is in the right format.</p><p><strong>Additional keyword arguments:</strong></p><ul><li><code>spec_colnames::Vector{Symbol} = nothing</code>: overwrites column names of the specification object</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/e0ce63c24e7eb8508c35d06948194cca50d4afb4/src/observed/missing.jl#L12-L55">source</a></section></article><h2 id="imply"><a class="docs-heading-anchor" href="#imply">imply</a><a id="imply-1"></a><a class="docs-heading-anchor-permalink" href="#imply" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StructuralEquationModels.SemImply" href="#StructuralEquationModels.SemImply"><code>StructuralEquationModels.SemImply</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype of all objects that can serve as the imply field of a SEM. Computed model-implied values that should be compared with the observed data to find parameter estimates, e. g. the model implied covariance or mean. If you would like to implement a different notation, e.g. LISREL, you should implement a subtype of SemImply.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/e0ce63c24e7eb8508c35d06948194cca50d4afb4/src/types.jl#L74-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StructuralEquationModels.RAM" href="#StructuralEquationModels.RAM"><code>StructuralEquationModels.RAM</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Model implied covariance and means via RAM notation.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">RAM(;
    specification,
    meanstructure = false,
    gradient = true,
    kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>specification</code>: either a <code>RAMMatrices</code> or <code>ParameterTable</code> object</li><li><code>meanstructure::Bool</code>: does the model have a meanstructure?</li><li><code>gradient::Bool</code>: is gradient-based optimization used</li></ul><p><strong>Extended help</strong></p><p><strong>Implementation</strong></p><p>Subtype of <code>SemImply</code>.</p><p><strong>RAM notation</strong></p><p>The model implied covariance matrix is computed as</p><p class="math-container">\[    \Sigma = F(I-A)^{-1}S(I-A)^{-T}F^T\]</p><p>and for models with a meanstructure, the model implied means are computed as</p><p class="math-container">\[    \mu = F(I-A)^{-1}M\]</p><p><strong>Interfaces</strong></p><ul><li><p><code>identifier(::RAM)</code>-&gt; Dict containing the parameter labels and their position</p></li><li><p><code>n_par(::RAM)</code> -&gt; Number of parameters</p></li><li><p><code>Σ(::RAM)</code> -&gt; model implied covariance matrix</p></li><li><p><code>μ(::RAM)</code> -&gt; model implied mean vector</p></li></ul><p>RAM matrices for the current parameter values:</p><ul><li><code>A(::RAM)</code></li><li><code>S(::RAM)</code></li><li><code>F(::RAM)</code></li><li><code>M(::RAM)</code></li></ul><p>Jacobians of RAM matrices w.r.t to the parameter vector <code>θ</code></p><ul><li><code>∇A(::RAM)</code> -&gt; <span>$∂vec(A)/∂θᵀ$</span></li><li><code>∇S(::RAM)</code> -&gt; <span>$∂vec(S)/∂θᵀ$</span></li><li><code>∇M(::RAM)</code> = <span>$∂M/∂θᵀ$</span></li></ul><p>Vector of indices of each parameter in the respective RAM matrix:</p><ul><li><code>A_indices(::RAM)</code></li><li><code>S_indices(::RAM)</code></li><li><code>M_indices(::RAM)</code></li></ul><p>Additional interfaces</p><ul><li><code>F⨉I_A⁻¹(::RAM)</code> -&gt; <span>$F(I-A)^{-1}$</span></li><li><code>F⨉I_A⁻¹S(::RAM)</code> -&gt; <span>$F(I-A)^{-1}S$</span></li><li><code>I_A(::RAM)</code> -&gt; <span>$I-A$</span></li><li><code>has_meanstructure(::RAM)</code> -&gt; <code>Val{Bool}</code> does the model have a meanstructure?</li></ul><p>Only available in gradient! calls:</p><ul><li><code>I_A⁻¹(::RAM)</code> -&gt; <span>$(I-A)^{-1}$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/e0ce63c24e7eb8508c35d06948194cca50d4afb4/src/imply/RAM/generic.jl#L4-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StructuralEquationModels.RAMSymbolic" href="#StructuralEquationModels.RAMSymbolic"><code>StructuralEquationModels.RAMSymbolic</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Subtype of <code>SemImply</code> that implements the RAM notation with symbolic precomputation.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">RAMSymbolic(;specification,
    vech = false,
    gradient = true,
    hessian = false,
    approximate_hessian = false,
    meanstructure = false,
    kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>specification</code>: either a <code>RAMMatrices</code> or <code>ParameterTable</code> object</li><li><code>meanstructure::Bool</code>: does the model have a meanstructure?</li><li><code>gradient::Bool</code>: is gradient-based optimization used</li><li><code>hessian::Bool</code>: is hessian-based optimization used</li><li><code>approximate_hessian::Bool</code>: for hessian based optimization: should the hessian be approximated</li><li><code>vech::Bool</code>: should the half-vectorization of Σ be computed (instead of the full matrix)   (automatically set to true if any of the loss functions is SemWLS)</li></ul><p><strong>Extended help</strong></p><p><strong>Implementation</strong></p><p>Subtype of <code>SemImply</code>.</p><p><strong>Interfaces</strong></p><ul><li><p><code>identifier(::RAMSymbolic)</code>-&gt; Dict containing the parameter labels and their position</p></li><li><p><code>n_par(::RAMSymbolic)</code> -&gt; Number of parameters</p></li><li><p><code>Σ(::RAMSymbolic)</code> -&gt; model implied covariance matrix</p></li><li><p><code>μ(::RAMSymbolic)</code> -&gt; model implied mean vector</p></li></ul><p>Jacobians (only available in gradient! calls)</p><ul><li><p><code>∇Σ(::RAMSymbolic)</code> -&gt; <span>$∂vec(Σ)/∂θᵀ$</span></p></li><li><p><code>∇μ(::RAMSymbolic)</code> -&gt; <span>$∂μ/∂θᵀ$</span></p></li><li><p><code>∇Σ_function(::RAMSymbolic)</code> -&gt; function to overwrite <code>∇Σ</code> in place,   i.e. <code>∇Σ_function(∇Σ, θ)</code>. Normally, you do not want to use this but simply   query <code>∇Σ(::RAMSymbolic)</code>.</p></li></ul><p>Hessians The computation of hessians is more involved, and uses the &quot;chain rule for hessian matrices&quot;. Therefore, we desribe it at length in the mathematical appendix of the online documentation, and the relevant interfaces are omitted here.</p><p>Additional interfaces</p><ul><li><code>has_meanstructure(::RAMSymbolic)</code> -&gt; <code>Val{Bool}</code> does the model have a meanstructure?</li></ul><p><strong>RAM notation</strong></p><p>The model implied covariance matrix is computed as</p><p class="math-container">\[    \Sigma = F(I-A)^{-1}S(I-A)^{-T}F^T\]</p><p>and for models with a meanstructure, the model implied means are computed as</p><p class="math-container">\[    \mu = F(I-A)^{-1}M\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/e0ce63c24e7eb8508c35d06948194cca50d4afb4/src/imply/RAM/symbolic.jl#L4-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StructuralEquationModels.ImplyEmpty" href="#StructuralEquationModels.ImplyEmpty"><code>StructuralEquationModels.ImplyEmpty</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Empty placeholder for models that don&#39;t need an imply part. (For example, models that only regularize parameters.)</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">ImplyEmpty(;specification, kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>specification</code>: either a <code>RAMMatrices</code> or <code>ParameterTable</code> object</li></ul><p><strong>Examples</strong></p><p>A multigroup model with ridge regularization could be specified as a <code>SemEnsemble</code> with one model per group and an additional model with <code>ImplyEmpty</code> and <code>SemRidge</code> for the regularization part.</p><p><strong>Extended help</strong></p><p><strong>Interfaces</strong></p><ul><li><code>identifier(::RAMSymbolic)</code>-&gt; Dict containing the parameter labels and their position</li><li><code>n_par(::RAMSymbolic)</code> -&gt; Number of parameters</li></ul><p><strong>Implementation</strong></p><p>Subtype of <code>SemImply</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/e0ce63c24e7eb8508c35d06948194cca50d4afb4/src/imply/empty.jl#L4-L27">source</a></section></article><h2 id="loss-functions"><a class="docs-heading-anchor" href="#loss-functions">loss functions</a><a id="loss-functions-1"></a><a class="docs-heading-anchor-permalink" href="#loss-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StructuralEquationModels.SemLoss" href="#StructuralEquationModels.SemLoss"><code>StructuralEquationModels.SemLoss</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SemLoss(args...; loss_weights = nothing, ...)</code></pre><p>Constructs the loss field of a SEM. Can contain multiple <code>SemLossFunction</code>s, the model is optimized over their sum. See also <a href="#StructuralEquationModels.SemLossFunction"><code>SemLossFunction</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>args...</code>: Multiple <code>SemLossFunction</code>s.</li><li><code>loss_weights::Vector</code>: Weights for each loss function. Defaults to unweighted optimization.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">my_ml_loss = SemML(...)
my_ridge_loss = SemRidge(...)
my_loss = SemLoss(SemML, SemRidge; loss_weights = [1.0, 2.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/e0ce63c24e7eb8508c35d06948194cca50d4afb4/src/types.jl#L16-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StructuralEquationModels.SemLossFunction" href="#StructuralEquationModels.SemLossFunction"><code>StructuralEquationModels.SemLossFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype for all loss functions of SEMs. If you want to implement a custom loss function, it should be a subtype of <code>SemLossFunction</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/e0ce63c24e7eb8508c35d06948194cca50d4afb4/src/types.jl#L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StructuralEquationModels.SemML" href="#StructuralEquationModels.SemML"><code>StructuralEquationModels.SemML</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Maximum likelihood estimation.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">SemML(;observed, meanstructure = false, approximate_hessian = false, kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>observed::SemObserved</code>: the observed part of the model</li><li><code>meanstructure::Bool</code>: does the model have a meanstructure?</li><li><code>approximate_hessian::Bool</code>: if hessian-based optimization is used, should the hessian be swapped for an approximation</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">my_ml = SemML(observed = my_observed)</code></pre><p><strong>Interfaces</strong></p><p>Analytic gradients are available, and for models without a meanstructure, also analytic hessians.</p><p><strong>Extended help</strong></p><p><strong>Implementation</strong></p><p>Subtype of <code>SemLossFunction</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/e0ce63c24e7eb8508c35d06948194cca50d4afb4/src/loss/ML/ML.jl#L6-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StructuralEquationModels.SemFIML" href="#StructuralEquationModels.SemFIML"><code>StructuralEquationModels.SemFIML</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Full information maximum likelihood estimation. Can handle observed data with missings.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">SemFIML(;observed, specification, kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>observed::SemObservedMissing</code>: the observed part of the model</li><li><code>specification</code>: either a <code>RAMMatrices</code> or <code>ParameterTable</code> object</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">my_fiml = SemFIML(observed = my_observed, specification = my_parameter_table)</code></pre><p><strong>Interfaces</strong></p><p>Analytic gradients are available.</p><p><strong>Extended help</strong></p><p><strong>Implementation</strong></p><p>Subtype of <code>SemLossFunction</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/e0ce63c24e7eb8508c35d06948194cca50d4afb4/src/loss/ML/FIML.jl#L4-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StructuralEquationModels.SemWLS" href="#StructuralEquationModels.SemWLS"><code>StructuralEquationModels.SemWLS</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Weighted least squares estimation.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">SemWLS(;
    observed,
    meanstructure = false, 
    wls_weight_matrix = nothing, 
    wls_weight_matrix_mean = nothing, 
    approximate_hessian = false, 
    kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>observed</code>: the <code>SemObserved</code> part of the model</li><li><code>meanstructure::Bool</code>: does the model have a meanstructure?</li><li><code>approximate_hessian::Bool</code>: should the hessian be swapped for an approximation</li><li><code>wls_weight_matrix</code>: the weight matrix for weighted least squares.    Defaults to GLS estimation (<span>$0.5*(D^T*kron(S,S)*D)$</span> where D is the duplication matrix    and S is the inverse ob the observed covariance matrix)</li><li><code>wls_weight_matrix_mean</code>: the weight matrix for the mean part of weighted least squares.    Defaults to GLS estimation (the inverse of the observed covariance matrix)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">my_wls = SemWLS(observed = my_observed)</code></pre><p><strong>Interfaces</strong></p><p>Analytic gradients are available, and for models without a meanstructure, also analytic hessians.</p><p><strong>Extended help</strong></p><p><strong>Implementation</strong></p><p>Subtype of <code>SemLossFunction</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/e0ce63c24e7eb8508c35d06948194cca50d4afb4/src/loss/WLS/WLS.jl#L6-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StructuralEquationModels.SemRidge" href="#StructuralEquationModels.SemRidge"><code>StructuralEquationModels.SemRidge</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Ridge regularization.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">SemRidge(;α_ridge, which_ridge, n_par, parameter_type = Float64, imply = nothing, kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>α_ridge</code>: hyperparameter for penalty term</li><li><code>which_ridge::Vector</code>: Vector of parameter labels (Symbols) or indices that indicate which parameters should be regularized.</li><li><code>n_par::Int</code>: number of parameters of the model</li><li><code>imply::SemImply</code>: imply part of the model</li><li><code>parameter_type</code>: type of the parameters</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">my_ridge = SemRidge(;α_ridge = 0.02, which_ridge = [:λ₁, :λ₂, :ω₂₃], n_par = 30, imply = my_imply)</code></pre><p><strong>Interfaces</strong></p><p>Analytic gradients and hessians are available.</p><p><strong>Extended help</strong></p><p><strong>Implementation</strong></p><p>Subtype of <code>SemLossFunction</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/e0ce63c24e7eb8508c35d06948194cca50d4afb4/src/loss/regularization/ridge.jl#L6-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StructuralEquationModels.SemConstant" href="#StructuralEquationModels.SemConstant"><code>StructuralEquationModels.SemConstant</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Constant loss term. Can be used for comparability to other packages.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">SemConstant(;constant_loss, kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>constant_loss::Number</code>: constant to add to the objective</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">    my_constant = SemConstant(constant_loss = 42.0)</code></pre><p><strong>Interfaces</strong></p><p>Analytic gradients and hessians are available.</p><p><strong>Extended help</strong></p><p><strong>Implementation</strong></p><p>Subtype of <code>SemLossFunction</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/e0ce63c24e7eb8508c35d06948194cca50d4afb4/src/loss/constant/constant.jl#L6-L27">source</a></section></article><h2 id="optimizer"><a class="docs-heading-anchor" href="#optimizer">optimizer</a><a id="optimizer-1"></a><a class="docs-heading-anchor-permalink" href="#optimizer" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StructuralEquationModels.SemOptimizer" href="#StructuralEquationModels.SemOptimizer"><code>StructuralEquationModels.SemOptimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype of all objects that can serve as the <code>optimizer</code> field of a SEM. Connects the SEM to its optimization backend and controls options like the optimization algorithm. If you want to connect the SEM package to a new optimization backend, you should implement a subtype of SemOptimizer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/e0ce63c24e7eb8508c35d06948194cca50d4afb4/src/types.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StructuralEquationModels.SemOptimizerOptim" href="#StructuralEquationModels.SemOptimizerOptim"><code>StructuralEquationModels.SemOptimizerOptim</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Connects to <code>Optim.jl</code> as the optimization backend.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">SemOptimizerOptim(;
    algorithm = LBFGS(), 
    options = Optim.Options(;f_tol = 1e-10, x_tol = 1.5e-8), 
    kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>algorithm</code>: optimization algorithm.</li><li><code>options::Optim.Options</code>: options for the optimization algorithm</li></ul><p><strong>Usage</strong></p><p>All algorithms and options from the Optim.jl library are available, for more information see  the Optim.jl online documentation.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">my_optimizer = SemOptimizerOptim()

# hessian based optimization with backtracking linesearch and modified initial step size
using Optim, LineSearches

my_newton_optimizer = SemOptimizerOptim(
    algorithm = Newton(
        ;linesearch = BackTracking(order=3), 
        alphaguess = InitialHagerZhang()
    )
)</code></pre><p><strong>Extended help</strong></p><p><strong>Interfaces</strong></p><ul><li><code>algorithm(::SemOptimizerOptim)</code></li><li><code>options(::SemOptimizerOptim)</code></li></ul><p><strong>Implementation</strong></p><p>Subtype of <code>SemOptimizer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/e0ce63c24e7eb8508c35d06948194cca50d4afb4/src/diff/optim.jl#L4-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StructuralEquationModels.SemOptimizerNLopt" href="#StructuralEquationModels.SemOptimizerNLopt"><code>StructuralEquationModels.SemOptimizerNLopt</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Connects to <code>NLopt.jl</code> as the optimization backend.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">SemOptimizerNLopt(;
    algorithm = :LD_LBFGS,
    options = Dict{Symbol, Any}(),
    local_algorithm = nothing, 
    local_options = Dict{Symbol, Any}(), 
    equality_constraints = Vector{NLoptConstraint}(), 
    inequality_constraints = Vector{NLoptConstraint}(), 
    kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>algorithm</code>: optimization algorithm.</li><li><code>options::Dict{Symbol, Any}</code>: options for the optimization algorithm</li><li><code>local_algorithm</code>: local optimization algorithm</li><li><code>local_options::Dict{Symbol, Any}</code>: options for the local optimization algorithm</li><li><code>equality_constraints::Vector{NLoptConstraint}</code>: vector of equality constraints</li><li><code>inequality_constraints::Vector{NLoptConstraint}</code>: vector of inequality constraints</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">my_optimizer = SemOptimizerNLopt()

# constrained optimization with augmented lagrangian
my_constrained_optimizer = SemOptimizerNLopt(;
    algorithm = :AUGLAG,
    local_algorithm = :LD_LBFGS,
    local_options = Dict(:ftol_rel =&gt; 1e-6),
    inequality_constraints = NLoptConstraint(;f = my_constraint, tol = 0.0),
)</code></pre><p><strong>Usage</strong></p><p>All algorithms and options from the NLopt library are available, for more information see  the NLopt.jl package and the NLopt online documentation. For information on how to use inequality and equality constraints,  see <a href="../constraints/constraints/#Constrained-optimization">Constrained optimization</a> in our online documentation.</p><p><strong>Extended help</strong></p><p><strong>Interfaces</strong></p><ul><li><code>algorithm(::SemOptimizerNLopt)</code></li><li><code>local_algorithm(::SemOptimizerNLopt)</code></li><li><code>options(::SemOptimizerNLopt)</code></li><li><code>local_options(::SemOptimizerNLopt)</code></li><li><code>equality_constraints(::SemOptimizerNLopt)</code></li><li><code>inequality_constraints(::SemOptimizerNLopt)</code></li></ul><p><strong>Implementation</strong></p><p>Subtype of <code>SemOptimizer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StructuralEquationModels/StructuralEquationModels.jl/blob/e0ce63c24e7eb8508c35d06948194cca50d4afb4/src/diff/NLopt.jl#L4-L58">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../first_model/">« A first model</a><a class="docs-footer-nextpage" href="../specification/specification/">Model specification »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 14 June 2023 11:30">Wednesday 14 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
